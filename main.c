#pragma config(Sensor, S3,     sensRight,      sensorSONAR)
#pragma config(Sensor, S4,     sensHead,       sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const short speed = 30;


int routeIndex;
int nextRoute0;
int nextRoute1;

long lastStepTime;

/*
states:

1 - waiting
2 - running route
3 - cross
*/
short state;

int route;

long startTime;
int dt;

float errSum1;
float errSum2;

const int sumTraceS1 = 50.0;
const int sumTraceS2 = 500.0;


const int wallDist = 17;

float sensCum1;
float sensCum2;

const float rightCriteria = 30;


void lineFollow()
{
	switch (state) {
  case 2:

    nxtDisplayTextLine(1, "r = %d", SensorValue[sensRight]);

    float ds = dt * speed;

    sensCum1 = (sensCum1 * (sumTraceS1*log(ds)-1) + SensorValue[sensRight])/(sumTraceS1*log(ds));
    sensCum2 = (sensCum2 * (sumTraceS2*log(ds)-1) + SensorValue[sensRight])/(sumTraceS2*log(ds));

    int summary = (sensCum1>rightCriteria);

    if (summary) {
      state = 1;
    }


		float err = - SensorValue[sensRight] +  wallDist;
		errSum1 = - sensCum1 + wallDist;
		errSum2 = - sensCum2 + wallDist;
		//errSum2 = 0;
		float corr = (err-0.0*errSum2)/30.0+0*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)/10000.0;
		nxtDisplayTextLine(2, "corr = %f", corr);
		nxtDisplayTextLine(3, "sensCum1 = %f", sensCum1);
		nxtDisplayTextLine(4, "sensCum2 = %f", sensCum2);
	  motor[motorB] = speed*(1+corr);
	  motor[motorC] = speed*(1-corr);
	  break;
	default:
	  //should not be in this state
  }
}

int i;
int routes[30] = {20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
//int routes[2] = {7,11};

void init() {
	i = 0;
	routeIndex = 0;
	nextRoute0 = routes[0];
	nextRoute1 = 0;
	route = routes[0];
  state = 2;
  wait1Msec(1000);
  startTime = nSysTime;
  lastStepTime = startTime;
  sensCum1 = sensorValue[sensRight];
  sensCum2 = sensorValue[sensRight];
}

void timeInc() {
	if (nSysTime - lastStepTime<10)
	{
		wait1Msec(10);
	}
	dt = nSysTime - lastStepTime;
	lastStepTime += dt;
}

void printInt(word n)
{
	string s;
	StringFormat(s, "%d", n);
	nxtDisplayTextLine(1,s);
}

void turnDirection(int angle) {
  switch (angle)
  {
  	case 90:
      motor[motorB] = 100;
      motor[motorC] = 0;
      wait1Msec(1300);
      break;
  	case -90:
      motor[motorC] = 100;
      motor[motorB] = 0;
      wait1Msec(1300);
      break;
  	case 100:
      motor[motorB] = 100;
      motor[motorC] = 0;
      wait1Msec(1100);
      break;
  	case -100:
      motor[motorC] = 100;
      motor[motorB] = 0;
      wait1Msec(1100);
      break;
  	case 60:
      motor[motorB] = 100;
      motor[motorC] = 0;
      wait1Msec(700);
      break;
  	case -60:
      motor[motorC] = 100;
      motor[motorB] = 0;
      wait1Msec(700);
      break;
    case 10:
      motor[motorB] = 0;
      motor[motorC] = 0;
      //wait1Msec(1000);
      motor[motorB] = 100;
      motor[motorC] = 20;
      wait1Msec(600);
      motor[motorB] = 0;
      motor[motorC] = 0;
      //wait1Msec(1000);
      motor[motorB] = 30;
      motor[motorC] = 100;
      wait1Msec(300);
      motor[motorB] = 0;
      motor[motorC] = 0;
      //wait1Msec(1000);
      break;
    case -10:
      motor[motorC] = 0;
      motor[motorB] = 0;
      //wait1Msec(1000);
      motor[motorC] = 100;
      motor[motorB] = 20;
      wait1Msec(600);
      motor[motorC] = 0;
      motor[motorB] = 0;
      //wait1Msec(1000);
      motor[motorC] = 30;
      motor[motorB] = 100;
      wait1Msec(300);
      motor[motorC] = 0;
      motor[motorB] = 0;
      //wait1Msec(1000);
      break;
    case 0:
      motor[motorB] = 100;
      motor[motorC] = 100;
      wait1Msec(100);
      break;
    default:
      //nothing here
  }
}

task main()
{

  init();

  /*while (true) {
    readData();
    nxtDisplayTextLine(1,"known = %d",routeIndex);
    nxtDisplayTextLine(2,"%d %d %d %d %d %d",routes[0],routes[1],routes[2],routes[3],routes[4],routes[5],routes[6]);
    wait1Msec(10)
  }*/

  timeInc();
  while(true)                           // Infinite loop
  {
    switch (state)
    {
      case 1:
        motor[motorC] = 0;
        motor[motorB] = 0;
        if (routes[i+1])
        {
        	state = 3;
        }
        break;
      case 2:
        lineFollow();
        break;
    }
  }
}
