#pragma config(Sensor, S3,     sensRight,      sensorSONAR)
#pragma config(Sensor, S2,     sensHead,       sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const short speed = 75;

long lastStepTime;

/*
states:

1 - stopped
2 - running right side
3 - turning left
4 - turning rigth
*/
short state;


long startTime;
int dt;


const float sumTraceS1 = 3.0;
const float sumTraceS2 = 100.0;

const int wallDist = 12;

float rightCum1;
float rightCum2;

float headCum1;
float headCum2;

int numRights;

const float rightCriteria = 30;
const float headCriteria = 20;

int getRight() {
  if (SensorValue [sensRight] > 200) {
    //return 0;
  }
  nxtDisplayString(1, "r = %d", SensorValue [sensRight]);
  return SensorValue [sensRight];
}

int getHead() {
  //if (SensorValue [sensHead] > 200) {
    //return 0;
  //}
  nxtDisplayString(2, "h = %d", SensorValue [sensHead]);
  return SensorValue [sensHead];
}


void lineFollow()
{

    nxtDisplayTextLine(1, "r = %d", getRight());
    nxtDisplayTextLine(2, "h = %d", getHead());

    float ds = dt * speed;

    rightCum1 = (rightCum1 * (sumTraceS1*log(ds)) + getRight())/(sumTraceS1*log(ds)+1);
    rightCum2 = (rightCum2 * (sumTraceS2*log(ds)) + getRight())/(sumTraceS2*log(ds)+1);

    headCum1 = (headCum1 * (sumTraceS1*log(ds)) + getHead())/(sumTraceS1*log(ds)+1);
    headCum2 = (headCum2 * (sumTraceS2*log(ds)) + getHead())/(sumTraceS2*log(ds)+1);

    int rightDoor = rightCum1 > rightCriteria;
    int headWall = headCum1 < headCriteria;

    if (rightDoor) {
      state = 4;
    }
    if (headWall) {
      state = 3;
    }


    float err = - getRight() +  wallDist;
    float errSum1 = - rightCum1 + wallDist;
    float errSum2 = - rightCum2 + wallDist;
    float corr = (err-0.9*errSum1)/10+0*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)/10000.0;
    if (abs(corr)>0.2) {
      corr = corr / abs(corr) * 0.2;
    }
    nxtDisplayTextLine(3, "sp(1-c) = %f", speed*(1.0-corr));
    //nxtDisplayTextLine(3, "rightCum1 = %f", rightCum1);
    //nxtDisplayTextLine(4, "rightCum2 = %f", rightCum2);
    if (lastStepTime - startTime > 100) {
      if (corr > 0) {
        motor[motorC] = speed*(1.0-corr);
        motor[motorB] = speed;
      } else {
        motor[motorC] = speed;
        motor[motorB] = speed*(1.0+corr);
      }
    }

}

void timeInc() {
  if (nSysTime - lastStepTime<10)
  {
    wait1Msec(10);
  }
  dt = nSysTime - lastStepTime;
  lastStepTime += dt;
}

void init() {
  state = 2;
  startTime = nSysTime;
  lastStepTime = startTime;
  timeInc();
  rightCum1 = getRight();
  rightCum2 = getRight();
  headCum1 = getHead();
  headCum2 = getHead();
}

void waitIdle() {
  while(nMotorRunState[motorB] != runStateIdle || nMotorRunState[motorC] != runStateIdle ){}
}

void printInt(word n)
{
  string s;
  StringFormat(s, "%d", n);
  nxtDisplayTextLine(1,s);
}

void straight(int dist) {
    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorC] = 0;

    nMotorEncoderTarget[motorB] = dist;
    nMotorEncoderTarget[motorC] = dist;
    motor[motorB] = 100;
    motor[motorC] = 100;
    waitIdle();
    //nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
    //nxtDisplayString(2, "%d", nMotorEncoder[motorC]);

  }

void sleep() {
    //motor[motorB] = 0;
    //motor[motorC] = 0;
    //wait1Msec(100);
  }


void findWall()
{
  while(getHead()>headCriteria && getRight() > rightCriteria)
    straight(300);
  init();
  }



void turnInstant(int angle){
  switch (angle) {
    case 90:
    {
      int a = - angle*(2.0);
      int sign = a >= 0 ? 1 : -1;
      nMotorEncoder[motorB] = 0;
      nMotorEncoder[motorC] = 0;

      nMotorEncoderTarget[motorB] = a;
      nMotorEncoderTarget[motorC] = a;
      motor[motorB] = sign * speed;
      motor[motorC] = - sign * speed;
      waitIdle();
      //nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
      //nxtDisplayString(2, "%d", nMotorEncoder[motorC]);
      break;
    }
    case -90:
    {
      int a = - angle*(2.5);
      int sign = a >= 0 ? 1 : -1;
      nMotorEncoder[motorB] = 0;
      nMotorEncoder[motorC] = 0;

      nMotorEncoderTarget[motorB] = a;
      nMotorEncoderTarget[motorC] = a;
      motor[motorB] = sign * speed;
      motor[motorC] = - sign * speed;
      waitIdle();
      //nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
      //nxtDisplayString(2, "%d", nMotorEncoder[motorC]);
    }
      break;
    default:
    {
      int a = - angle*(2.5);
      int sign = a >= 0 ? 1 : -1;
      nMotorEncoder[motorB] = 0;
      nMotorEncoder[motorC] = 0;

      nMotorEncoderTarget[motorB] = a;
      nMotorEncoderTarget[motorC] = a;
      motor[motorB] = sign * speed;
      motor[motorC] = - sign * speed;
      waitIdle();
      //nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
      //nxtDisplayString(2, "%d", nMotorEncoder[motorC]);
      break;
    }
  }
}

void correction()
{
  int min = getRight();
  int ind = 1;
  int indexmin = 1;

  while (indexmin-ind<10){
    turnInstant(-1);
    ind = ind - 1;
    if(getRight()<min)
    {
      min = getRight();
      indexmin = ind;
      }
    //sleep();
  }
  while(ind - indexmin < 10)
  {
    turnInstant(1);
    ind = ind + 1;
    if (getRight()<min)
      {
         min = getRight();
         indexmin = ind;
    }
    //sleep();
  }
  turnInstant(-10);
}

task main()
{
  wait1Msec(1000);
  //init();

  /*
  turnInstant(90);
  sleep();
  straight(100);
  sleep();
  turnInstant(-90);
  sleep();
  straight(100);
  sleep();
  turnInstant(-90);
  sleep();
  straight(100);
  sleep();
  turnInstant(-90);
  sleep();
  straight(100);
  sleep();
  turnInstant(-90);
  sleep();
  straight(100);
  sleep();
  return;
  */
  while(true)
  {
    nxtDisplayString(4, "st = %d", state);
    switch (state)
    {
      case 0:
        findWall();
        sleep();
        correction();
        init();
      case 1:
        motor[motorC] = 0;
        motor[motorB] = 0;
        break;
      case 2:
        lineFollow();
        timeInc();
        break;
      case 3:
        sleep();
        turnInstant(-90);
        sleep();
        init();
        numRights = 0;
        break;
      case 4:
        if (numRights >= 2) {
          state = 0;
          break;
        }
        numRights = numRights + 1;
        sleep();
        straight(450);
        sleep();
        turnInstant(90);
        sleep();
        straight(500);
        sleep();
        init();
        break;
      default:
        //nothing there
    }
  }

}
