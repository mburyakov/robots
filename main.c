#pragma config(Sensor, S3,     sensRight,      sensorSONAR)
#pragma config(Sensor, S4,     sensHead,       sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const short speed = 30;

long lastStepTime;

/*
states:

1 - stopped
2 - running right side
3 - turning left
4 - turning rigth
*/
short state;


long startTime;
int dt;


const float sumTraceS1 = 50.0;
const float sumTraceS2 = 500.0;

const int wallDist = 17;

float rightCum1;
float rightCum2;

float headCum1;
float headCum2;


const float rightCriteria = 30;
const float headCriteria = 7;


void lineFollow()
{
	switch (state) {
  case 2:

    nxtDisplayTextLine(1, "r = %d", SensorValue[sensRight]);

    float ds = dt * speed;

    rightCum1 = (rightCum1 * (sumTraceS1*log(ds)-1) + SensorValue[sensRight])/(sumTraceS1*log(ds));
    rightCum2 = (rightCum2 * (sumTraceS2*log(ds)-1) + SensorValue[sensRight])/(sumTraceS2*log(ds));

    headCum1 = (headCum1 * (sumTraceS1*log(ds)-1) + SensorValue[sensHead])/(sumTraceS1*log(ds));
    headCum2 = (headCum2 * (sumTraceS2*log(ds)-1) + SensorValue[sensHead])/(sumTraceS2*log(ds));

    int rightDoor = rightCum1 > rightCriteria;
    int headWall = headCum1 < headCriteria;

    if (rightDoor) {
      state = 4;
    }
    if (headWall) {
      state = 3;
    }


		float err = - SensorValue[sensRight] +  wallDist;
		float errSum1 = - rightCum1 + wallDist;
		float errSum2 = - rightCum2 + wallDist;
		float corr = (err+0.0*errSum2)/30.0+0*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)/10000.0;
		nxtDisplayTextLine(2, "corr = %f", corr);
		nxtDisplayTextLine(3, "rightCum1 = %f", rightCum1);
		nxtDisplayTextLine(4, "rightCum2 = %f", rightCum2);
	  motor[motorB] = speed*(1+corr);
	  motor[motorC] = speed*(1-corr);
	  break;
	default:
	  //should not be in this state
  }
}

void timeInc() {
	if (nSysTime - lastStepTime<10)
	{
		wait1Msec(10);
	}
	dt = nSysTime - lastStepTime;
	lastStepTime += dt;
}

void init() {
  state = 2;
  wait1Msec(500);
  startTime = nSysTime;
  lastStepTime = startTime;
  timeInc();
  rightCum1 = SensorValue[sensRight];
  rightCum2 = SensorValue[sensRight];
}

void printInt(word n)
{
	string s;
	StringFormat(s, "%d", n);
	nxtDisplayTextLine(1,s);
}


task main()
{

  init();
  while(true)
  {
    switch (state)
    {
      case 1:
        motor[motorC] = 0;
        motor[motorB] = 0;
        break;
      case 2:
        lineFollow();
        break;
    }
  }
}
