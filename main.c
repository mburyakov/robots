#pragma config(Sensor, S3,     sensRight,      sensorSONAR)
#pragma config(Sensor, S4,     sensHead,       sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const short speed = 30;

long lastStepTime;

/*
states:

1 - stopped
2 - running right side
3 - turning left
4 - turning rigth
*/
short state;


long startTime;
int dt;


const float sumTraceS1 = 10.0;
const float sumTraceS2 = 100.0;

const int wallDist = 12;

float rightCum1;
float rightCum2;

float headCum1;
float headCum2;


const float rightCriteria = 30;
const float headCriteria = 15;

void lineFollow()
{

    nxtDisplayTextLine(1, "r = %d", SensorValue[sensRight]);
    nxtDisplayTextLine(2, "h = %d", SensorValue[sensHead]);

    float ds = dt * speed;

    rightCum1 = (rightCum1 * (sumTraceS1*log(ds)-1) + SensorValue[sensRight])/(sumTraceS1*log(ds));
    rightCum2 = (rightCum2 * (sumTraceS2*log(ds)-1) + SensorValue[sensRight])/(sumTraceS2*log(ds));

    headCum1 = (headCum1 * (sumTraceS1*log(ds)-1) + SensorValue[sensHead])/(sumTraceS1*log(ds));
    headCum2 = (headCum2 * (sumTraceS2*log(ds)-1) + SensorValue[sensHead])/(sumTraceS2*log(ds));

    int rightDoor = rightCum1 > rightCriteria;
    int headWall = headCum1 < headCriteria;

    if (rightDoor) {
      state = 4;
    }
    if (headWall) {
      state = 3;
    }


    float err = - SensorValue[sensRight] +  wallDist;
    float errSum1 = - rightCum1 + wallDist;
    float errSum2 = - rightCum2 + wallDist;
    float corr = (err-0.99*errSum1)/2.0+0*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)*(errSum1+0.0*errSum2)/10000.0;
    if (abs(corr)>0.2) {
      corr = corr / abs(corr) * 0.2;
    }
    //nxtDisplayTextLine(2, "corr = %f", corr);
    //nxtDisplayTextLine(3, "rightCum1 = %f", rightCum1);
    //nxtDisplayTextLine(4, "rightCum2 = %f", rightCum2);
    if (lastStepTime - startTime > 100) {
      motor[motorB] = speed*(1+corr);
      motor[motorC] = speed*(1-corr);
    }
}

void timeInc() {
  if (nSysTime - lastStepTime<10)
  {
    wait1Msec(10);
  }
  dt = nSysTime - lastStepTime;
  lastStepTime += dt;
}

void init() {
  state = 2;
  startTime = nSysTime;
  lastStepTime = startTime;
  timeInc();
  rightCum1 = SensorValue[sensRight];
  rightCum2 = SensorValue[sensRight];
  headCum1 = SensorValue[sensHead];
  headCum2 = SensorValue[sensHead];
}

void waitIdle() {
  while(nMotorRunState[motorB] != runStateIdle || nMotorRunState[motorC] != runStateIdle ){}
}

void printInt(word n)
{
  string s;
  StringFormat(s, "%d", n);
  nxtDisplayTextLine(1,s);
}

void straight(int dist) {
    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorC] = 0;

    nMotorEncoderTarget[motorB] = dist;
    nMotorEncoderTarget[motorC] = dist;
    motor[motorB] = 100;
    motor[motorC] = 100;
    waitIdle();
    nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
    nxtDisplayString(2, "%d", nMotorEncoder[motorC]);

  }

void sleep() {
    motor[motorB] = 0;
    motor[motorC] = 0;
    wait1Msec(1000);
  }


void turnInstant(int angle){
  switch (angle) {
    case 180:
      int b = 470;
      nMotorEncoder[motorB] = 0;
      nMotorEncoder[motorC] = 0;

      nMotorEncoderTarget[motorB] = b;
      nMotorEncoderTarget[motorC] = b;
      motor[motorB] = -100;
      motor[motorC] = 100;
      waitIdle();
      nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
      nxtDisplayString(2, "%d", nMotorEncoder[motorC]);
      break;
    default:
      int a = - angle*(8.0/3.0);
      int sign = a >= 0 ? 1 : -1;
      nMotorEncoder[motorB] = 0;
      nMotorEncoder[motorC] = 0;

      nMotorEncoderTarget[motorB] = a;
      nMotorEncoderTarget[motorC] = a;
      motor[motorB] = sign * 100;
      motor[motorC] = - sign * 100;
      waitIdle();
      nxtDisplayString(1, "%d", nMotorEncoder[motorB]);
      nxtDisplayString(2, "%d", nMotorEncoder[motorC]);
      break;

  }
}

task main()
{

  init();

  //turnInstant(90);
  //sleep();
  //turnInstant(-90);
  //sleep();
  //return;
  while(true)
  {
    switch (state)
    {
      case 1:
        motor[motorC] = 0;
        motor[motorB] = 0;
        break;
      case 2:
        lineFollow();
        timeInc();
        break;
      case 3:
        sleep();
        turnInstant(-90);
        sleep();
        init();
        break;
      case 4:
        sleep();
        straight(300);
        sleep();
        turnInstant(90);
        sleep();
        straight(500);
        sleep();
        init();
        break;
      default:
        //nothing there
    }
  }

}
